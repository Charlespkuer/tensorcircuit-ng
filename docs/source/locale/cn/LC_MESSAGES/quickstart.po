# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020, The TensorCircuit Authors
# This file is distributed under the same license as the tensorcircuit
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version:  tensorcircuit\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-02-15 15:06+0800\n"
"PO-Revision-Date: 2022-02-15 14:47+0800\n"
"Last-Translator: \n"
"Language: cn\n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../source/quickstart.rst:3
msgid "Quick Start"
msgstr "快速上手"

#: ../../source/quickstart.rst:6
msgid "Install from GitHub"
msgstr "从GitHub安装"

#: ../../source/quickstart.rst:8
msgid ""
"For beta version usage, one needs to install tensorcircuit package from "
"GitHub. For development and PR workflow, please refer to `contribution "
"<contribution.html>`__ instead."
msgstr ""
"如需使用测试版本，则需要从 GitHub 安装 tensorcircuit 包。 对于开发和 PR 工作流程，请另外参考 `贡献 "
"<contribution.html>`__  。"

#: ../../source/quickstart.rst:10
msgid ""
"For private tensorcircuit-dev repo, one needs to firstly configure the "
"SSH key on GitHub and locally, please refer to `GitHub doc "
"<https://docs.github.com/en/authentication/connecting-to-github-with-"
"ssh>`__"
msgstr ""
"对于私有 tensorcircuit 开发库，首先需要在 GitHub 和本地配置 SSH 密钥, 请参考 `GitHub 文档 "
"<https://docs.github.com/en/authentication/connecting-to-github-with-"
"ssh>`__ 。"

#: ../../source/quickstart.rst:12
msgid ""
"Then try ``pip3 install --force-reinstall git+ssh://git@github.com/quclub"
"/tensorcircuit-dev.git`` in shell."
msgstr ""
"然后尝试在命令行窗口中输入``pip3 install --force-reinstall "
"git+ssh://git@github.com/quclub/tensorcircuit-dev.git``。"

#: ../../source/quickstart.rst:14
msgid ""
"Depending on one's need, one may further pip install tensorflow (for "
"tensorflow backend) or jax and jaxlib (for jax backend) or `cotengra "
"<https://github.com/jcmgray/cotengra>`__ (for more advanced tensornetwork"
" contraction path solver)."
msgstr ""
"基于个人情况，用户可能需要进一步安装 tensorflow, jax 或 jaxlib 或 `cotengra "
"<https://github.com/jcmgray/cotengra>`_ 以满足后端要求。"

#: ../../source/quickstart.rst:16
msgid ""
"If one needs circuit visualization on JupyterLab, python package `wand "
"<https://docs.wand-py.org/en/0.6.7/>`__ and its binary bindings as well "
"as LaTeX installation is required."
msgstr ""
"如果需要在 JupyterLab 中进行电路可视化，则需要 python 库  `wand <https://docs.wand-"
"py.org/en/0.6.7/>`__ 及其二进制绑定以及 LaTeX 的安装。"

#: ../../source/quickstart.rst:20
msgid "Circuit Object"
msgstr "电路对象"

#: ../../source/quickstart.rst:22
msgid "The basic object for TensorCircuit is ``tc.Circuit``."
msgstr "TensorCircuit的基本对象是 “tc.Circuit\"。"

#: ../../source/quickstart.rst:24
msgid "Initialize the circuit with the number of qubits ``c=tc.Circuit(n)``."
msgstr "用量子比特数(n) “c=tc.Circuit(n)” 来初始化电路。"

#: ../../source/quickstart.rst:26
msgid "**Input states:**"
msgstr "**输入状态:**"

#: ../../source/quickstart.rst:28
#, fuzzy
msgid ""
"The default input function for the circuit is:math:`\\vert 0^n \\rangle`."
" One can change this to other wavefunctions by directly feeding the "
"inputs state vectors w: ``c=tc.Circuit(n, inputs=w)``."
msgstr ""
"电路的默认输入函数是：math:`\\vert 0^n \\rangle`。 可以通过直接输入输入状态向量 w "
"将其更改为其他波函数：`c=tc.Circuit(n, inputs=w)`。"

#: ../../source/quickstart.rst:30
#, fuzzy
msgid ""
"One can also feed matrix product states as input states for the circuit, "
"but we leave MPS/MPO usage for future sections."
msgstr "也可以将矩阵乘积状态作为电路的输入状态，但我们将 矩阵乘积状态/矩阵乘积算子 的使用留给以后的部分。"

#: ../../source/quickstart.rst:32
msgid "**Quantum gates:**"
msgstr "**量子门:*"

#: ../../source/quickstart.rst:34
msgid ""
"We can apply gates on circuit objects. For example, using ``c.H(1)`` or "
"``c.rx(2, theta=0.2)``, we cam apply Hadamard gate on qubit 1 (0-based) "
"or apply Rx gate on qubit 2 as :math:`e^{-i\\theta/2 X}`."
msgstr ""
"我们可以将门应用于电路对象。 例如，使用“cH(1)”或“c.rx(2, theta=0.2)”，我们可以将 Hadamard 门应用于 "
"量子比特1 （基于0）或将 Rx 门应用于 量子比特2： math：`e^{-i\\theta/2 X}`。"

#: ../../source/quickstart.rst:36
msgid "The same rule also apply to multi-qubit gates, such as ``c.cnot(0, 1)``."
msgstr ""

#: ../../source/quickstart.rst:38
msgid "There are also highly customizable gates, two instances are:"
msgstr ""

#: ../../source/quickstart.rst:40
msgid ""
"``c.exp1(0, 1, unitary=m, theta=0.2)`` which is for the exponential gate "
":math:`e^{i\\theta m}` of any matrix m as long as :math:`m^2=1`."
msgstr ""

#: ../../source/quickstart.rst:42
msgid ""
"``c.any(0, 1, unitary=m)`` which is for applying the unitary gate m on "
"the circuit."
msgstr ""

#: ../../source/quickstart.rst:44
msgid "These two examples are flexible and support gates on any number of qubits."
msgstr ""

#: ../../source/quickstart.rst:46
msgid "**Measurements and Expectations:**"
msgstr ""

#: ../../source/quickstart.rst:48
msgid ""
"The most straightforward way to get the output from the circuit object is"
" getting the output wavefunction in vector form as ``c.state()``."
msgstr ""

#: ../../source/quickstart.rst:50
msgid ""
"For bitstring sampling, we have ``c.perfect_sampling()`` which returns "
"the bitstring and the corresponding probability amplitude."
msgstr ""

#: ../../source/quickstart.rst:52
msgid ""
"To measure part of the qubits, we can use ``c.measure(0, 1)``, if we want"
" to know the corresponding probability of the measurement output, try "
"``c.measure(0, 1, with_prob=True)``. The measure API is by default non-"
"jittable, but we also have a jittable version as ``c.measure_jit(0, 1)``."
msgstr ""

#: ../../source/quickstart.rst:54
msgid ""
"The measurement and sampling utilize advanced algorithms based on "
"tensornetwork and thus requires no knowledge or space for the full "
"wavefunction."
msgstr ""

#: ../../source/quickstart.rst:56
msgid "See example below:"
msgstr ""

#: ../../source/quickstart.rst:74
msgid ""
"To compute expectation values for local observables, we have "
"``c.expectation([tc.gates.z(), [0]], [tc.gates.z(), [1]])`` for "
":math:`\\langle Z_0Z_1 \\rangle` or ``c.expectation([tc.gates.x(), "
"[0]])`` for :math:`\\langle X_0 \\rangle`."
msgstr ""

#: ../../source/quickstart.rst:76
msgid ""
"This expectation API is rather flexible, as one can measure an m on "
"several qubits as ``c.expectation([m, [0, 1, 2]])``."
msgstr ""

#: ../../source/quickstart.rst:78
msgid "**Circuit visualization:**"
msgstr ""

#: ../../source/quickstart.rst:80
msgid ""
"``c.vis_tex()`` can generate tex code for circuit visualization based on "
"LaTeX `quantikz <https://arxiv.org/abs/1809.03842>`__ package."
msgstr ""

#: ../../source/quickstart.rst:82
msgid ""
"There are also some automatic pipeline helper functions to directly "
"generate figures from tex code, but they require extra installations in "
"the environment."
msgstr ""

#: ../../source/quickstart.rst:84
msgid ""
"``render_pdf(tex)`` function requires full installation of LaTeX locally."
" And in Jupyter environment, we may prefer ``render_pdf(tex, "
"notebook=True)`` to return jpg figures, which further require wand "
"magicwand library installed, see `here <https://docs.wand-"
"py.org/en/latest/>`__."
msgstr ""

#: ../../source/quickstart.rst:86
msgid "**Circuit Intermediate Representation:**"
msgstr ""

#: ../../source/quickstart.rst:88
msgid ""
"TensorCircuit provides its own circuit IR as a python list of dicts. This"
" IR can be further utilized to run compiling, generate serialization qasm"
" or render circuit figures."
msgstr ""

#: ../../source/quickstart.rst:90
msgid ""
"The IR is given as a list, each element is a dict containing information "
"on one gate that applied on the circuit. Note gate attr in the dict is "
"actually a python function that returns the gate's node."
msgstr ""

#: ../../source/quickstart.rst:102
msgid "Programming Paradigm"
msgstr ""

#: ../../source/quickstart.rst:104
msgid ""
"The most common case and the most typical programming paradigm for "
"TensorCircuit is to evaluate the circuit output and the corresponding "
"quantum gradients, which is common in variational quantum algorithms."
msgstr ""

#: ../../source/quickstart.rst:131
msgid ""
"Also for a non-quantum example (linear regression) demonstrating the "
"backend agnostic feature, pytree supports variables, AD/jit/vmap usage, "
"and variational optimization loops. Please refer to the example script: "
"`linear regression example <https://github.com/quclub/tensorcircuit-"
"dev/blob/master/examples/universal_lr.py>`_. This example might be more "
"friendly to machine learning community since it is purely classical while"
" also showcasing the main features and paradigms of tensorcircuit."
msgstr ""

#: ../../source/quickstart.rst:134
msgid ""
"If the user have no intention to maintain the application code in a "
"backend agnostic fashion, the API for ML frameworks can be more handily "
"used and connected with the TensorCircuit API."
msgstr ""

#: ../../source/quickstart.rst:169
msgid "Automatic differentiation, JIT and vectorized parallelism"
msgstr ""

#: ../../source/quickstart.rst:171
msgid ""
"For concepts of AD, JIT and VMAP, please refer to `Jax documentation "
"<https://jax.readthedocs.io/en/latest/jax-101/index.html>`__ ."
msgstr ""

#: ../../source/quickstart.rst:173
msgid ""
"The related API design in TensorCircuit closely follows the functional "
"programming design pattern in Jax with some slight differences. So we "
"strongly recommend users learning some basics about Jax no matter which "
"ML backend they intend to use."
msgstr ""

#: ../../source/quickstart.rst:175
msgid "**AD support:**"
msgstr ""

#: ../../source/quickstart.rst:177
msgid ""
"Gradients, vjps, jvps, natural gradients, Jacobians and Hessians. AD is "
"the base for all modern machine learning libraries."
msgstr ""

#: ../../source/quickstart.rst:181
msgid "**JIT support:**"
msgstr ""

#: ../../source/quickstart.rst:183
msgid ""
"Parameterized quantum circuits can run in a blink. Always use jit if the "
"circuit will get evaluations multiple times, it can greatly boost the "
"simulation with two or three order time reduction. But also be cautious, "
"users need to be familiar with jit, otherwise the jitted function may "
"return unexpected results or recompiling on every hit (wasting lots of "
"time). To learn more about the jit mechanism, one can refer to "
"documentations or blogs on ``tf.function`` or ``jax.jit``, though these "
"two still have subtle differences."
msgstr ""

#: ../../source/quickstart.rst:187
msgid "**VMAP support:**"
msgstr ""

#: ../../source/quickstart.rst:189
msgid ""
"Inputs, parameters, measurements, circuit structures, Monte Carlo noise "
"can all be evaluated in parallel. To learn more about vmap mechanism, one"
" can refer to documentations or blogs on ``tf.vectorized_map`` or "
"``jax.vmap``."
msgstr ""

#: ../../source/quickstart.rst:194
msgid "Backend Agnosticism"
msgstr ""

#: ../../source/quickstart.rst:196
msgid ""
"TensorCircuit supports TensorFlow, Jax and PyTorch backends. We recommend"
" using TensorFlow or Jax backend, since PyTorch lacks advanced jit and "
"vmap features."
msgstr ""

#: ../../source/quickstart.rst:198
msgid ""
"The backend can be set as ``K=tc.set_backend(\"jax\")`` and ``K`` is the "
"backend with a full set of APIs as a conventional ML framework, which can"
" also be accessed by ``tc.backend``."
msgstr ""

#: ../../source/quickstart.rst:221
msgid ""
"The supported APIs in backend come from two sources, one part is "
"implemented in `TensorNetwork package "
"<https://github.com/google/TensorNetwork/blob/master/tensornetwork/backends/abstract_backend.py>`__"
" and the other part is implemented in `TensorCircuit package "
"<modules.html#module-tensorcircuit.backends>`__."
msgstr ""

#: ../../source/quickstart.rst:226
msgid "Switch the dtype"
msgstr ""

#: ../../source/quickstart.rst:228
msgid ""
"TensorCircuit supports simulation using 32/64 bit precession. The default"
" dtype is 32-bit as \"complex64\". Change this by "
"``tc.set_dtype(\"complex128\")``."
msgstr ""

#: ../../source/quickstart.rst:231
msgid ""
"``tc.dtypestr`` always returns the current dtype string: either "
"\"complex64\" or \"complex128\"."
msgstr ""

#: ../../source/quickstart.rst:235
msgid "Setup the contractor"
msgstr ""

#: ../../source/quickstart.rst:237
msgid ""
"TensorCircuit is a tensornetwork contraction based on quantum circuit "
"simulator. A contractor is for searching the optimal contraction path of "
"the circuit tensornetwork."
msgstr ""

#: ../../source/quickstart.rst:239
msgid ""
"There are various advanced contractors provided by third-party packages, "
"such as `opt-einsum <https://github.com/dgasmith/opt_einsum>`__ and "
"`cotengra <https://github.com/jcmgray/cotengra>`__."
msgstr ""

#: ../../source/quickstart.rst:241
msgid ""
"`opt-einsum` is shipped with TensorNetwork package. To use cotengra, one "
"need to pip install it; kahypar is also recommended to install with "
"cotengra."
msgstr ""

#: ../../source/quickstart.rst:243
msgid "Some setup cases:"
msgstr ""

#: ../../source/quickstart.rst:269
msgid ""
"For advanced configurations on cotengra contractors, please refer to "
"cotengra `doc "
"<https://cotengra.readthedocs.io/en/latest/advanced.html>`__ and more "
"fancy examples can be found at `contractor tutorial "
"<https://github.com/quclub/tensorcircuit-"
"tutorials/blob/master/tutorials/contractors.ipynb>`__."
msgstr ""

#: ../../source/quickstart.rst:271
msgid "**Setup in function or context level**"
msgstr ""

#: ../../source/quickstart.rst:273
msgid ""
"Beside global level setup, we can also setup the backend, the dtype, and "
"the contractor in function level or context manager level:"
msgstr ""

#: ../../source/quickstart.rst:291
msgid "Noisy Circuit simulation"
msgstr ""

#: ../../source/quickstart.rst:293
msgid "**Monte Carlo State Simulator:**"
msgstr ""

#: ../../source/quickstart.rst:295
msgid ""
"For the Monte Carlo trajectory noise simulator, unitary Kraus channel can"
" be handled easily. TensorCircuit also support fully jittable and "
"differentiable general Kraus channel Monte Carlo simulation, though."
msgstr ""

#: ../../source/quickstart.rst:307
msgid "**Density Matrix Simulator:**"
msgstr ""

#: ../../source/quickstart.rst:309
msgid ""
"Density matrix simulator ``tc.DMCircuit`` simulates the noise in a full "
"form, but takes twice qubits as noiseless simulation. The API is "
"basically the same as ``tc.Circuit``."
msgstr ""

#: ../../source/quickstart.rst:313
msgid "MPS and MPO"
msgstr ""

#: ../../source/quickstart.rst:315
msgid ""
"TensorCircuit has its own class for MPS and MPO originally defined in "
"TensorNetwork as ``tc.QuVector``, ``tc.QuOperator``."
msgstr ""

#: ../../source/quickstart.rst:317
msgid ""
"``tc.QuVector`` can be extracted from ``tc.Circuit`` as the tensor "
"network form for the output state (uncontracted) by ``c.quvector()``."
msgstr ""

#: ../../source/quickstart.rst:319
msgid ""
"The QuVector form a wavefunction w, which can also be fed into Circuit as"
" the inputs state as ``c=tc.Circuit(n, mps_inputs=w)``."
msgstr ""

#: ../../source/quickstart.rst:321
msgid ""
"For example, a quick way to calculate the wavefunction overlap without "
"explicitly computing the state amplitude is given as below:"
msgstr ""

#: ../../source/quickstart.rst:340
msgid "Interfaces"
msgstr ""

#: ../../source/quickstart.rst:342
msgid "**PyTorch interface to hybrid with PyTorch modules:**"
msgstr ""

#: ../../source/quickstart.rst:344
msgid ""
"As we have mentioned in backend section, PyTorch backend may lack "
"advanced features. This doesn't mean we cannot hybrid advanced circuit "
"module with PyTorch neural module. We can run the quantum function on "
"tensorflow or jax backend, while wrapping it with a torch interface."
msgstr ""

#: ../../source/quickstart.rst:372
msgid "**Scipy interface to utilize scipy optimizers:**"
msgstr ""

#: ../../source/quickstart.rst:374
msgid ""
"Automatically transform quantum functions as scipy-compatible values and "
"grad functions as provided for scipy interface with ``jac=True``."
msgstr ""

#: ../../source/quickstart.rst:400
msgid "Templates as Shortcuts"
msgstr ""

#: ../../source/quickstart.rst:402
msgid "**Measurements:**"
msgstr ""

#: ../../source/quickstart.rst:404
msgid "**Circuit blocks:**"
msgstr ""

#~ msgid "There are also highly customizable gates, two representatives are:"
#~ msgstr ""

#~ msgid ""
#~ "These two examples are flexible and "
#~ "support gate on any number of "
#~ "qubits."
#~ msgstr ""

#~ msgid "**Measurements and expectations:**"
#~ msgstr ""

#~ msgid ""
#~ "The most directly way to get the"
#~ " output from the circuit object is"
#~ " just getting the output wavefunction "
#~ "in vector form as ``c.state()``."
#~ msgstr ""

#~ msgid ""
#~ "The measurement and sampling utilize "
#~ "advanced algorithm based on tensornetwork, "
#~ "and thus requires no knowledge or "
#~ "space for the full wavefunction. See "
#~ "example below:"
#~ msgstr ""

#~ msgid ""
#~ "This expectation API is rather flexible,"
#~ " as one can measure any matrix "
#~ "m on several qubits as "
#~ "``c.expectation([m, [0, 1, 2]])``."
#~ msgstr ""

#~ msgid ""
#~ "There are also some automatic pipeline"
#~ " helper functions to directly generate "
#~ "figures from tex code, but they "
#~ "require extra installs in the "
#~ "enviroment."
#~ msgstr ""

#~ msgid ""
#~ "``render_pdf(tex)`` function requires full "
#~ "installation of LaTeX locally. And in"
#~ " Jupyter enviroment, we may prefer "
#~ "``render_pdf(tex, notebook=True)`` to return "
#~ "jpg figures, which further require wand"
#~ " magicwand library installed, see `here "
#~ "<https://docs.wand-py.org/en/latest/>`__."
#~ msgstr ""

#~ msgid ""
#~ "The IR is given as a list, "
#~ "each element is a dict containing "
#~ "information on one gate that applied "
#~ "on the circuit. Note gate attr in"
#~ " the dict is actually a python "
#~ "function that returns the gate node."
#~ msgstr ""

#~ msgid ""
#~ "The most common use case and the"
#~ " most typical programming paradigm for "
#~ "TensorCircuit is to evaluate the circuit"
#~ " output and the corresponding quantum "
#~ "gradients, which is common in "
#~ "variational quantum algorithms."
#~ msgstr ""

#~ msgid ""
#~ "Also for a non-quantum simpler "
#~ "example (linear regression) demonstrating the"
#~ " backend agnostic feature, pytree support"
#~ " for variables, AD/jit/vmap usage and "
#~ "variational optimization loops, please refer"
#~ " to the example script: `linear "
#~ "regression example <https://github.com/quclub"
#~ "/tensorcircuit-dev/blob/master/examples/universal_lr.py>`_. "
#~ "This example might be more friendly "
#~ "to machine learning community since it"
#~ " is purely classical while also "
#~ "showcasing the main features and "
#~ "paradigms of tensorcircuit."
#~ msgstr ""

#~ msgid ""
#~ "If the users have no intension to"
#~ " maintain the application code in a"
#~ " backend agnostic fashion, the API "
#~ "for ML frameworks can be more "
#~ "freely used and interleaved with "
#~ "TensorCircuit API."
#~ msgstr ""

#~ msgid ""
#~ "The related API design in TensorCircuit"
#~ " closely follows the functional programming"
#~ " design pattern in Jax with some "
#~ "slight differences. So we strongly "
#~ "recommend the users to learn some "
#~ "basics about Jax no matter which "
#~ "ML backend they intend to use."
#~ msgstr ""

#~ msgid ""
#~ "Parameterized quantum circuit can run in"
#~ " a blink. Always use jit if the"
#~ " circuit will get evaluations multiple "
#~ "times, it greatly boost the simulation"
#~ " efficiency with two or three order"
#~ " time reduction. But also be caution,"
#~ " you need to be an expert on"
#~ " jit, otherwise the jitted function "
#~ "may return unexpected results or "
#~ "recompiling on every hit (wasting lots"
#~ " of time). To learn more about "
#~ "jit mechanism, one can refer to "
#~ "documentations or blogs on ``tf.function`` "
#~ "or ``jax.jit``, though these two still"
#~ " have subtle differences."
#~ msgstr ""

#~ msgid ""
#~ "Inputs, parameters, measurements, circuit "
#~ "structures, Monte Carlo noise can all"
#~ " be parallelly evaluate. To learn "
#~ "more about vmap mechanism, one can "
#~ "refer to documentations or blogs on "
#~ "``tf.vectorized_map`` or ``jax.vmap``."
#~ msgstr ""

#~ msgid ""
#~ "TensorCircuit support TensorFlow, Jax and "
#~ "PyTorch backends. We recommend to use"
#~ " TensorFlow or Jax backend, since "
#~ "PyTorch lacks advanced jit and vmap "
#~ "features."
#~ msgstr ""

#~ msgid ""
#~ "TensorCircuit supports simulation using 32/64"
#~ " bit percesion. The default dtype is"
#~ " 32-bit as \"complex64\". Change this "
#~ "by ``tc.set_dtype(\"complex128\")``."
#~ msgstr ""

#~ msgid ""
#~ "``tc.dtypestr`` always return the current "
#~ "dtype string: either \"complex64\" or "
#~ "\"complex128\"."
#~ msgstr ""

#~ msgid ""
#~ "There are various advanced contractor "
#~ "provided by the third-party packages,"
#~ " such as `opt-einsum "
#~ "<https://github.com/dgasmith/opt_einsum>`__ and `cotengra"
#~ " <https://github.com/jcmgray/cotengra>`__."
#~ msgstr ""

#~ msgid ""
#~ "For advanced configuration on cotengra "
#~ "contractor, please refer cotengra `doc "
#~ "<https://cotengra.readthedocs.io/en/latest/advanced.html>`__ and"
#~ " more fancy examples can be found "
#~ "at `contractor tutorial <https://github.com/quclub"
#~ "/tensorcircuit-"
#~ "tutorials/blob/master/tutorials/contractors.ipynb>`__."
#~ msgstr ""

#~ msgid ""
#~ "Besides global level setup, we can "
#~ "also setup the backend, the dtype "
#~ "and the contractor in function level "
#~ "or context manager level:"
#~ msgstr ""

#~ msgid ""
#~ "For Monte Carlo trajector noise "
#~ "simulator, unitary Kraus channel can be"
#~ " handled easily. TensorCircuit also support"
#~ " fully jittable and differentable general"
#~ " Kraus channel Monte Carlo simulation, "
#~ "though."
#~ msgstr ""

#~ msgid ""
#~ "Densitymatrix simulator ``tc.DMCircuit`` simulates"
#~ " the noise in a full form, but"
#~ " takes twice qubits as noiseless "
#~ "simulation. The API is basically the "
#~ "same as ``tc.Circuit``."
#~ msgstr ""

#~ msgid ""
#~ "The QuVector form wavefunction w can "
#~ "also be fed into Circuit as the"
#~ " inputs state as ``c=tc.Circuit(n, "
#~ "mps_inputs=w)``."
#~ msgstr ""

#~ msgid ""
#~ "For example, the quick way to "
#~ "calculate the wavefunction overlap without "
#~ "explicitly computing the state amplitude "
#~ "is given as below:"
#~ msgstr ""

#~ msgid ""
#~ "As we have mentioned in backend "
#~ "section, PyTorch backend may lack "
#~ "advanced features. This does't mean we"
#~ " cannot hybrid advanced circuit module "
#~ "with PyTorch neural module, we can "
#~ "run the quantum function on tensorflow"
#~ " or jax backend, while wrap it "
#~ "with a torch interface."
#~ msgstr ""

#~ msgid ""
#~ "Automatically transform quantum functions as"
#~ " scipy-compatible value and grad "
#~ "function as provided for scipy interface"
#~ " with ``jac=True``."
#~ msgstr ""

#~ msgid ""
#~ "For the concepts of AD, JIT and"
#~ " VMAP, please refer to `Jax "
#~ "documentation "
#~ "<https://jax.readthedocs.io/en/latest/jax-101/index.html>`__ ."
#~ msgstr ""

#~ msgid ""
#~ "The related API design in TensorCircuit"
#~ " closely follows the functional programming"
#~ " design pattern in Jax with some "
#~ "slight differences. So we strongly "
#~ "recommend users to learn some basics "
#~ "about Jax no matter which ML "
#~ "backend they intend to use."
#~ msgstr ""

#~ msgid ""
#~ "TensorCircuit is a tensornetwork contraction"
#~ " based quantum circuit simulator. A "
#~ "contractor is for searching the optimal"
#~ " contraction path of the circuit "
#~ "tensornetwork."
#~ msgstr ""

#~ msgid ""
#~ "There are various advanced contractors "
#~ "provided by the third-party packages,"
#~ " such as `opt-einsum "
#~ "<https://github.com/dgasmith/opt_einsum>`__ and `cotengra"
#~ " <https://github.com/jcmgray/cotengra>`__."
#~ msgstr ""

#~ msgid ""
#~ "`opt-einsum` is shipped with "
#~ "TensorNetwork package. To use cotengra, "
#~ "one need to pip install it "
#~ "separately, kahypar is also recommended "
#~ "to install with cotengra."
#~ msgstr ""

#~ msgid ""
#~ "For advanced configurations on cotengra "
#~ "contractors, please refer cotengra `doc "
#~ "<https://cotengra.readthedocs.io/en/latest/advanced.html>`__ and"
#~ " more fancy examples can be found "
#~ "at `contractor tutorial <https://github.com/quclub"
#~ "/tensorcircuit-"
#~ "tutorials/blob/master/tutorials/contractors.ipynb>`__."
#~ msgstr ""

#~ msgid ""
#~ "Besides global level setup, we can "
#~ "also setup the backend, the dtype, "
#~ "and the contractor in function level "
#~ "or context manager level:"
#~ msgstr ""

